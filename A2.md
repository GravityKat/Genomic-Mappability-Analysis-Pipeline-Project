BMEG 424/524 Assignment 2
================
FirstName LastName (student#)

- [BMEG 424 Assignment 2:
  Mappability](#bmeg-424-assignment-2-mappability)
  - [Introduction:](#introduction)
    - [Software and Tools:](#software-and-tools)
    - [Data:](#data)
    - [Goals and Objectives:](#goals-and-objectives)
    - [Other notes:](#other-notes)
    - [Submission:](#submission)
  - [Experiment and Analysis:](#experiment-and-analysis)
    - [1. Creating a modular mapping pipeline (7
      pts)](#1-creating-a-modular-mapping-pipeline-7-pts)
    - [a. Building the basic rules](#a-building-the-basic-rules)
    - [b. Read length](#b-read-length)
    - [c. Reference genome](#c-reference-genome)
    - [d. Paired vs. Single End
      Alignment](#d-paired-vs-single-end-alignment)
    - [2. Testing factors affecting mappability (4.5
      pts)](#2-testing-factors-affecting-mappability-45-pts)
    - [3. Analyzing the results (18
      pts)](#3-analyzing-the-results-18-pts)
      - [a. Effect of read length on
        mappability](#a-effect-of-read-length-on-mappability)
      - [b. Effect of reference genome on
        mappability](#b-effect-of-reference-genome-on-mappability)
      - [c. Effect of alignment mode on
        mappability](#c-effect-of-alignment-mode-on-mappability)
  - [Discussion (8 pts):](#discussion-8-pts)
- [Contributions](#contributions)

``` r
knitr::opts_chunk$set(echo = TRUE)
```

# BMEG 424 Assignment 2: Mappability

## Introduction:

### Software and Tools:

In this assignment we will be using the following tools: -
[bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml) -
[samtools](http://www.htslib.org/doc/samtools.html) -
[sambamba](http://lomereiter.github.io/sambamba/docs/sambamba-view.html) -
[trimmomatic](http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/TrimmomaticManual_V0.32.pdf) -
[liftover](https://genome.ucsc.edu/cgi-bin/hgLiftOver) -
[bedtools](https://bedtools.readthedocs.io/en/latest/) -
[conda](https://conda.io/docs/) -
[snakemake](https://snakemake.readthedocs.io/en/stable/)

### Data:

Your data is located in the following directory: `/projects/bmeg/A2/`.
You have been provided with 2 fastq files (forward and reverse reads)
named `H3K27me3_iPSC_SRA60_subset_<1/2>.fastq.gz` These files contain a
subset of the reads from a H3K27me3 ChIP-seq experiment performed on
human iPSCs. Don’t worry about what ChIP-seq experiments are or what
they measure, that will be the topic of next weeks assignment.

### Goals and Objectives:

In this assignment you will be using the concepts you learned in class
to investigate the effect of various factors on mappability. You will be
using the snakemake workflow management system to create a modular
mapping pipeline. You will then use this pipeline to test the effect of
read length, reference genome, and alignment mode on mappability.
Finally, you will analyze the results of your experiments and discuss
your findings.

### Other notes:

- As always you must cite any sources you use in your assignment (class
  slides are exempted). This includes any code you use from
  StackOverflow, ChatGPT, Github, etc. Failure to cite your sources will
  result in (at least) a zero on the assignment.
- You are going to be using another snakemake pipeline, please ensure
  you are limiting snakemake to a single core and less than 4GB of
  memory. You can do this by adding the following to your snakemake
  command: `--cores 1 --resources mem_mb=4000`
- You will be reusing several of the same tools between A1 and A2. To
  save time you can clone your A1 conda environment
  (<https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#cloning-an-environment>)
  and install the additional tools you need for this assignment into
  your A2 env. Check if you have the tools installed by using
  `conda list` or simply typing the tool in the command line after your
  environment is activated.
- Remember to gzip any large files you produce working and delete them
  when you are done with the assignment. If you take up too much space
  in your home directory you will not be able to save your work and will
  prevent others from doing the same, you will also make your TAs very
  unhappy :(

### Submission:

Submit your assignment as a knitted RMarkdown document. You will push
your knitted RMarkdown document to your github repository (one for each
group). You will then submit the link to your repo, along with the names
and student numbers of all students who worked on the assignment to the
assignment 2 page on Canvas. Your assignment should be submitted, and
your last commit should be made, before 11:59pm on the day of the
deadline. Late assignments will will be deducted 10% per day late.
Assignments will not be accepted after 3 days past the deadline.

## Experiment and Analysis:

### 1. Creating a modular mapping pipeline (7 pts)

**A snakemake file is provided in Part 2. Simply update the shell
portions which you will complete below.** If you are stuck on running
snakemake, simply execute the commands individually in the terminal
manually and proceed to perform your analysis in Part 3 and Discussion
questions.

### a. Building the basic rules

Our mapping rule will be similar to the rule you used in the last
assignment for mapping reads to the genome using bowtie2. For your
convenience, a correct single-ended mapping rule has been provided
below. Reference it as necessary in the rules you write.

    rule align:
        input:
            fastq = "path/to/data/{sample}.fastq.gz",
        output:
            sam = "aligned/{sample}.sam"
        shell:
            "bowtie2 -x /projects/bmeg/indexes/hg38/hg38_bowtie2_index "
            "-U {input.fastq} -S {output.sam}"

We’ll also have to convert the aligned sam files to bam format (binary
sam). As before you can do this using samtools. You can install samtools
into your A2 conda environment with
`conda install -c bioconda samtools`. The samtools manual can be found
[here](http://www.htslib.org/doc/samtools.html). For your convenience, a
correct conversion rule has been provided below:

    rule sam_to_bam:
        input:
            sam = "aligned/{sample}.sam"
        output: 
            bam = "aligned/{sample}.bam"
        shell:
            "samtools view -h -S -b -o {output.bam} {input.sam}"

We will also need a rule that will count the number of uniquely mapped
reads in our sam file generated by bowtie2. In order to do this we will
use a useful multipart tool called sambamba. Sambamba is a tool for
working with sam and bam files. You can install sambamba into your A2
conda environment with `conda install -c bioconda sambamba`. The
sambamba manual can be found
[here](http://lomereiter.github.io/sambamba/docs/sambamba-view.html).

    #?# 1. Fill in (where it says <complete command>) the following rule which will count the number of uniquely mapped reads in a sam file. (0.5 pts)

    rule count_unique_reads:
        input:
            bam = "aligned/{sample}_CROP{length}_{genome}_{mode}.bam"
        output:
            counts = "counts/{sample}_CROP{length}_{genome}_{mode}_nReads.txt"
        shell:
            """
            sambamba view -c -F "[XS] == null and not unmapped and not duplicate" {input.bam} > {output.counts}
            """

### b. Read length

The first factor affecting mappability which we will test in this
assignment is read length. In order to test this variable we will have
to trim our reads to different lengths before aligning them. We will use
the trimmomatic tool to trim our reads. You can install trimmmomatic
into your A2 conda environment with
`conda install -c bioconda trimmomatic`.

We will want to use the SE option for single end reads. The trimmomatic
manual can be found
[here](http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/TrimmomaticManual_V0.32.pdf).

    #?# 2. Fill in the rule (where it says <complete command>) such that you can dynamically trim reads to different lengths BEFORE mapping. (1 pts)

    rule trim_reads_single:
        input:
            read_1 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_1.fastq.gz"
        output:
            read_1 = "trimmed/{sample}_CROP{length}_1.fastq.gz"
        params:
            length = "{length}"  # The desired read length
        shell:
            """
            trimmomatic SE -phred33 {input.read_1} {output.read_1} CROP:{params.length}
            """

    rule trim_reads_paired:
        input:
            read_1 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_1.fastq.gz",
            read_2 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_2.fastq.gz"
        output:
            read_1 = "trimmed/{sample}_CROP{length}_1.fastq.gz",
            read_2 = "trimmed/{sample}_CROP{length}_2.fastq.gz"
        params:
            length = "{length}"  # The desired read length
        shell:
            """
            trimmomatic PE -phred33 {input.read_1} {input.read_2} \
            {output.read_1} /dev/null {output.read_2} /dev/null \
            CROP:{params.length}
            """

### c. Reference genome

Next we will see if mapping to different reference genomes affects
mappability. We will use both the hg19 and hg38 reference genomes. Both
genomes are available, indexed, at
`/projects/bmeg/genomes/<genome>/indexes/`

To compare reads mapped to different genomes we will need to use the
ucsc-liftover tool to convert the hg19 coordinates to hg38 coordinates.
You can install the liftover tool into your A2 conda environment with
`conda install ucsc-liftover`. You will also need to use
`/projects/bmeg/A2/hg19ToHg38.over.chain.gz` for conversion of hg19 to
hg38 coordinates.

    #?# 3. Complete the following rules' shell portion to dynamically map reads to different reference genomes. All resulting alignments should have hg38 coordinates irrespective of which genome was used. (1 pts)

    rule align_single: 
        input:
            fastq1 = "trimmed/{sample}_CROP{length}_1.fastq.gz"
        output:
            sam = "aligned/{sample}_CROP{length}_{genome}_{mode}.sam"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg19/hg19_bowtie2_index \
                -U {input.fastq1} -S {output.sam};
            elif [ "{params.genome}" == "hg38" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg38/hg38_bowtie2_index \
                -U {input.fastq1} -S {output.sam};
            else
                echo "Invalid genome"
                exit 1;
            fi
            """

    rule bam_to_bed:
        input:
            bam = "aligned/{sample}_CROP{length}_{genome}_{mode}.bam"
        output:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}.bed"
        shell:
            """
            bedtools bamtobed -i {input.bam} > {output.bed}
            """

    rule liftover:
        input:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}.bed",
            chain = "/projects/bmeg/A2/hg19ToHg38.over.chain.gz"
        output:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}_lifted_hg38.bed",
            unlifted = "bed/{sample}_CROP{length}_{genome}_{mode}_unlifted.bed",
            confirmation = "aligned/lifted_over_{sample}_CROP{length}_{genome}_{mode}.done"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                liftOver {input.bed} {input.chain} {output.bed} {output.unlifted};
                touch {output.confirmation};
            elif [ "{params.genome}" == "hg38" ]; then
                echo "No need to lift over";
                touch {output.confirmation};
            else
                echo "Invalid genome";
                exit 1;
            fi
            """

### d. Paired vs. Single End Alignment

The files you have been using so far have been single end reads.
However, paired end reads are also commonly used in sequencing. In
paired end sequencing, the same DNA fragment is sequenced from both
ends. This allows us to get information about the distance between the
two ends of the fragment. This information can be used to improve the
accuracy of the alignment.

    #?# 4. Update the rule from Part a. to do paired-end alignment. (1 pts)

    rule align_paired:
        input:
            fastq1 = "trimmed/{sample}_CROP{length}_1.fastq.gz",
            fastq2 = "trimmed/{sample}_CROP{length}_2.fastq.gz"
        output:
            sam = "aligned/{sample}_CROP{length}_{genome}_{mode}.sam"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg19/hg19_bowtie2_index \
                -1 {input.fastq1} -2 {input.fastq2} -S {output.sam};
            elif [ "{params.genome}" == "hg38" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg38/hg38_bowtie2_index \
                -1 {input.fastq1} -2 {input.fastq2} -S {output.sam};
            else
                echo "Invalid mode"
                exit 1;
            fi
            """

### 2. Testing factors affecting mappability (4.5 pts)

In order to keep track of the experiments we are running we should
modify our pipeline to use a config file. This will allow us to easily
change the parameters of our pipeline without having to modify the
pipeline itself.

    #?# 5. Create a config file which will allow you to easily change the parameters of your pipeline. Paste the file (without parameter values) below. (0.5 pts)

    length:
    genome:
    mode:

Now we are going to run our pipeline with different parameters in order
to test the effect of the various factors on mappability. Use the
following parameters:

    Length: 50, 100, 150
        While testing length, use only the hg38 genome and single end mode (on read 1)
    Genome: hg19, hg38
        While testing genome, use only the 50bp read length and single end mode (on read 1)
    Alignment mode: paired, single
        While testing alignment mode, use only the 50bp read length and hg38 genome.

    #?# 6. Paste your complete snakefile and include a visualization of the DAG below (include the settings on your config file as part of the filename for the DAG image). (3 pts)
    # snakemake --dag | dot -Tsvg > dag.svg
    # HINT: You'll want to look at the ruleorder directive in the snakemake documentation.
    #Snakefile
    #The parameters were manipulated by changing the values in the yaml file for prior to each run
    configfile: "config.yaml"
    LENGTH = config["length"]
    GENOME = config["genome"]
    MODE = config["mode"]

    SAMPLES = ["H3K27me3_iPSC_SRA60_subset"]

    rule all:
        input:
            expand("bed/{sample}_CROP{length}_{genome}_{mode}.bed", length = LENGTH, genome = GENOME, mode = MODE, sample = SAMPLES),
            expand("counts/{sample}_CROP{length}_{genome}_{mode}_nReads.txt",length = LENGTH, genome = GENOME, mode = MODE, sample = SAMPLES),
            expand("aligned/lifted_over_{sample}_CROP{length}_hg19_{mode}.done", length = LENGTH, genome = GENOME, mode = MODE, sample = SAMPLES) if GENOME == "hg19" else []

    if MODE=="single":
        ruleorder: trim_reads_single > trim_reads_paired
        ruleorder: align_single > align_paired
    elif MODE=="paired":
        ruleorder: trim_reads_paired > trim_reads_single
        ruleorder: align_paired > align_single
    else:
        print("Invalid mode")
        exit(1)

    rule sam_to_bam:
        input:
            sam = "aligned/{sample}.sam"
        output: 
            bam = "aligned/{sample}.bam"
        shell:
            "samtools view -h -S -b -o {output.bam} {input.sam}"

    rule count_unique_reads:
        input:
            bam = "aligned/{sample}_CROP{length}_{genome}_{mode}.bam"
        output:
            counts = "counts/{sample}_CROP{length}_{genome}_{mode}_nReads.txt"
        shell:
            """
            sambamba view -c -F "[XS] == null and not unmapped and not duplicate" {input.bam} > {output.counts}
            """

    rule trim_reads_single:
        input:
            read_1 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_1.fastq.gz"
        output:
            read_1 = "trimmed/{sample}_CROP{length}_1.fastq.gz"
        params:
            length = "{length}"  # The desired read length
        shell:
            """
            trimmomatic SE -phred33 {input.read_1} {output.read_1} CROP:{params.length}
            """

    rule trim_reads_paired:
        input:
            read_1 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_1.fastq.gz",
            read_2 = "/projects/bmeg/A2/H3K27me3_iPSC_SRA60_subset_2.fastq.gz"
        output:
            read_1 = "trimmed/{sample}_CROP{length}_1.fastq.gz",
            read_2 = "trimmed/{sample}_CROP{length}_2.fastq.gz"
        params:
            length = "{length}"  # The desired read length
        shell:
            """
            trimmomatic PE -phred33 {input.read_1} {input.read_2} \
            {output.read_1} /dev/null {output.read_2} /dev/null \
            CROP:{params.length}
            """

    rule align_single: 
        input:
            fastq1 = "trimmed/{sample}_CROP{length}_1.fastq.gz"
        output:
            sam = "aligned/{sample}_CROP{length}_{genome}_{mode}.sam"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg19/hg19_bowtie2_index \
                -U {input.fastq1} -S {output.sam};
            elif [ "{params.genome}" == "hg38" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg38/hg38_bowtie2_index \
                -U {input.fastq1} -S {output.sam};
            else
                echo "Invalid genome"
                exit 1;
            fi
            """

    rule bam_to_bed:
        input:
            bam = "aligned/{sample}_CROP{length}_{genome}_{mode}.bam"
        output:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}.bed"
        shell:
            """
            bedtools bamtobed -i {input.bam} > {output.bed}
            """

    rule liftover:
        input:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}.bed",
            chain = "/projects/bmeg/A2/hg19ToHg38.over.chain.gz"
        output:
            bed = "bed/{sample}_CROP{length}_{genome}_{mode}_lifted_hg38.bed",
            unlifted = "bed/{sample}_CROP{length}_{genome}_{mode}_unlifted.bed",
            confirmation = "aligned/lifted_over_{sample}_CROP{length}_{genome}_{mode}.done"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                liftOver {input.bed} {input.chain} {output.bed} {output.unlifted};
                touch {output.confirmation};
            elif [ "{params.genome}" == "hg38" ]; then
                echo "No need to lift over";
                touch {output.confirmation};
            else
                echo "Invalid genome";
                exit 1;
            fi
            """

    rule align_paired:
        input:
            fastq1 = "trimmed/{sample}_CROP{length}_1.fastq.gz",
            fastq2 = "trimmed/{sample}_CROP{length}_2.fastq.gz"
        output:
            sam = "aligned/{sample}_CROP{length}_{genome}_{mode}.sam"
        params:
            genome = config["genome"]
        shell:
            """
            if [ "{params.genome}" == "hg19" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg19/hg19_bowtie2_index \
                -1 {input.fastq1} -2 {input.fastq2} -S {output.sam};
            elif [ "{params.genome}" == "hg38" ]; then
                bowtie2 -x /projects/bmeg/indexes/hg38/hg38_bowtie2_index \
                -1 {input.fastq1} -2 {input.fastq2} -S {output.sam};
            else
                echo "Invalid mode"
                exit 1;
            fi
            """

![CROP50_hg38_single_dag](/A2images/CROP50_hg38_single_dag.svg)
![CROP100_hg38_single_dag](/A2images/CROP100_hg38_single_dag.svg)
![CROP150_hg38_single_dag](/A2images/CROP150_hg38_single_dag.svg)
![CROP50_hg19_single_dag](/A2images/CROP50_hg19_single_dag.svg)
![CROP50_hg38_paired_dag](/A2images/CROP50_hg38_paired_dag.svg)

For full marks you will need:

- One Snakefile

- The ability to alternatively run with either single or paired-end
  alignment mode (also trimming the reads appropriately)

- The ability to align to either hg19 or hg38

- The following outputs: trimmed fastq, sam, bam, bed, and counts files
  for each run (not all of these need to be in the rule all necessarily)

- Different runs should not overwrite one another (i.e. the output files
  should be named differently for each run)

You can use `snakemake -np` to perform a dry-run and debug your
snakefile. Once you are confident that your snakefile is working
correctly you can run it on the server. Run your snakefile using the
following command: `snakemake --cores 1 --resources mem_mb=4000`. Each
time modify the config file to change the parameters of your pipeline.
Once you have completed all of your runs (5 runs in total, remember that
snakemake, when configured correctly will not run redundant jobs) you
can move on to the next section.

**NOTE: Each run will take 15-20min to complete. Most of the time will
be taken up by the align rule which will run each time.** Please ensure
you start early.

### 3. Analyzing the results (18 pts)

#### a. Effect of read length on mappability

Download the count files generated by your various runs onto your
*local* computer into your A2 project folder. Once you have downloaded
the files you can begin your analysis in R.

``` r
#?# 7. Plot the number of uniquely mapped reads for each read length (1 pt).
library(ggplot2)

file_hg38_single_50 <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg38_single_nReads.txt"
file_hg38_single_100 <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP100_hg38_single_nReads.txt"
file_hg38_single_150 <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP150_hg38_single_nReads.txt"
file_hg19_single_50 <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg19_single_nReads.txt"
file_hg38_paired_50 <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg38_paired_nReads.txt"

hg38_single_50 <- as.numeric(readLines(file_hg38_single_50))
hg38_single_100 <- as.numeric(readLines(file_hg38_single_100))
hg38_single_150 <- as.numeric(readLines(file_hg38_single_150))
hg19_single_50 <- as.numeric(readLines(file_hg19_single_50))
hg38_paired_50 <- as.numeric(readLines(file_hg38_paired_50))

df_counts <- data.frame(
  ReadLength = c(50, 100, 150, 50, 50),
  Genome = c("hg38", "hg38", "hg38", "hg19", "hg38"),
  Mode = c("single", "single", "single", "single", "paired"),
  UniqueReads = c(hg38_single_50, hg38_single_100, hg38_single_150, hg19_single_50, hg38_paired_50)
)

df_counts_filtered <- df_counts[df_counts$Genome == "hg38" & df_counts$Mode == "single", ]

ggplot(df_counts_filtered, aes(x = factor(ReadLength), y = UniqueReads, fill = factor(ReadLength))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = UniqueReads), vjust = -0.5, size = 3) +
  labs(title = "Effect of Read Length on Mappability", 
       x = "Read Length (bp)", 
       y = "Unique Mapped Reads") +
  theme_minimal()
```

``` r
#?# 8. Based on the results of your analysis, what is the relationship between read length and mappability? Define the relationship mathematically. (1 pts)

library(ggplot2)

# Subset the data to include only hg38 and single-end runs
df_counts_filtered <- df_counts[df_counts$Genome == "hg38" & df_counts$Mode == "single", ]

lm_model <- lm(UniqueReads ~ ReadLength, data = df_counts_filtered)

a <- coef(lm_model)[2]  # Slope
b <- coef(lm_model)[1]  # Intercept

# Print the equation of the line
cat("Mathematical Model: M =", round(a, 2), "* L +", round(b, 2), "\n")
```

    ## Mathematical Model: M = 1705.45 * L + 1322063

``` r
ggplot(df_counts_filtered, aes(x = ReadLength, y = UniqueReads)) +
  geom_point(size = 4, color = "blue") +  # Data points
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Regression line
  geom_text(aes(label = UniqueReads), vjust = -0.5, size = 3) +  # Labels on points
  labs(title = "Linear Relationship: Read Length vs. Unique Mapped Reads",
       x = "Read Length (bp)",
       y = "Unique Mapped Reads") +
  theme_minimal()
```

    ## `geom_smooth()` using formula = 'y ~ x'

![](/A2graphs/readLengthVsMappability.png)<!-- -->

``` r
# The relationship between read length and mappability is that as read length increases, the number of uniquely mapped reads increases. It is a linear relationship, at least in regard to the 3 different read lengths. It can be defined by the equation in the output below:
```

\#?# 9. What would you predict the number of uniquely mapped reads would
be for a 25bp read? What assumptions are you making in your prediction?
(2 pt) \# HINT: Think about what the result above would indicate for the
mapping rate of a 0bp read.

    For a 25bp read, the number of uniquely mapped reads would likely be lower than for a 50bp read, as shorter reads have a higher probability of mapping to multiple locations in the genome, making them harder to assign uniquely. The trend suggests that as read length decreases, mappability also decreases. More specifically the number would be 1,364,699 based on the previously mentioned mathematical model.

#### b. Effect of reference genome on mappability

``` r
#?# 10. Plot the number of uniquely mapped reads for each reference genome (1 pt)

# Load necessary library
library(ggplot2)

hg38_file <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg38_single_nReads.txt"
hg19_file <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg19_single_nReads.txt"

hg38_reads <- as.numeric(readLines(hg38_file))
hg19_reads <- as.numeric(readLines(hg19_file))

data <- data.frame(
  Genome = c("hg38", "hg19"),
  Reads = c(hg38_reads, hg19_reads),
  Color = c("#77DD77", "#FF6961")  # Pastel green and pastel red
)

y_min <- min(data$Reads) - 5000
y_max <- max(data$Reads) + 5000
y_breaks <- seq(y_min, y_max, by = 5000)

ggplot(data, aes(x = Genome, y = Reads, fill = Color)) +
  geom_bar(stat = "identity") + 
  geom_text(aes(label = Reads), vjust = -0.5, size = 3) +  # Add labels on bars
  scale_fill_identity() +  # Use custom pastel colors
  theme_minimal() +
  labs(
    title = "Number of Uniquely Mapped Reads for Each Reference Genome",
    x = "Reference Genome",
    y = "Number of Uniquely Mapped Reads"
  ) +
  theme(
    axis.text.x = element_text(size = 12)
  )
```

![](/A2graphs/uniquelyMappedPerGenome.png)<!-- -->

\#?# 11. Interpret the plot above, what does it tell you about the the
hg19 and hg38 alignments? (1.5 pts)

    The reference genomes hg38 and hg19 have values that are very close to each other, when all other parameters in the yaml are kept the same. This suggests that the genomes perform similarly in terms of mappability. Small differences could be due to changes in sequence representation, gap closing, or improved genome annotations in hg38. In summary, hg38 does not appear to significantly improve or reduce mappability compared to hg19, at least in terms of the total number of uniquely mapped reads.

    https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2620-0

Next we will check to see not whether the number of uniquely mapping
reads has changed, but whether the reads are mapping to the same
location after lifting over and whether the alignment *quality* has
changed. In order to compare the positions/scores of reads we will have
to extract the relevant information from the bed files generated by the
pipeline. You can use the `join` command to merge the hg19_lifted_over
and hg38 bed files together. *Make sure that you sort your bedfiles by
**read name** before merging*. You can sort the bedfiles using the
`sort` command.

You only want to include these columns in your merged bed file:
`read_ID,chr_hg38,start_hg38,end_hg38,score_hg38,chr_hg19,start_hg19,end_hg19,score_hg19`
(hg19 refers to the lifted over file though its start and end
coordinates are technically referring to hg38 as well.) You should have
each of these columns *in the order specified*. You can use arguments of
the `join` command to modify which columns end up in the output and in
which order.

``` r
#?# 12. Create a barchart illustrating the difference in mean alignment score between the hg19 (lifted-over) and hg38 alignments for each of the autosomal chromosomes (2 pts).

library(ggplot2)
library(dplyr)
```

    ## 
    ## Attaching package: 'dplyr'

    ## The following objects are masked from 'package:stats':
    ## 
    ##     filter, lag

    ## The following objects are masked from 'package:base':
    ## 
    ##     intersect, setdiff, setequal, union

``` r
merged_data <- read.table("~/Downloads/merged_lifted_vs_direct.bed", header=FALSE, stringsAsFactors=FALSE)

colnames(merged_data) <-c("Read_ID", "Chrom_hg38", "Start_hg38", "End_hg38", "Score_hg38", "Chrom_hg19", "Start_hg19", "End_hg19", "Score_hg19")

autosomal_chroms <- paste0("chr", 1:22)
merged_data <- merged_data %>% 
  filter(Chrom_hg38 %in% autosomal_chroms & Chrom_hg19 %in% autosomal_chroms)

autosomal_chroms <- paste0("chr", 1:22)
merged_data <- merged_data %>% 
  filter(Chrom_hg38 %in% autosomal_chroms & Chrom_hg19 %in% autosomal_chroms)

library(data.table)
```

    ## 
    ## Attaching package: 'data.table'

    ## The following objects are masked from 'package:dplyr':
    ## 
    ##     between, first, last

``` r
# Convert to data.table
merged_data <- as.data.table(merged_data)

mean_scores <- merged_data[, .(
  Mean_Score_hg38 = mean(Score_hg38, na.rm=TRUE),
  Mean_Score_hg19 = mean(Score_hg19, na.rm=TRUE)
), by=Chrom_hg38]

mean_scores_long <- melt(mean_scores, id.vars="Chrom_hg38", 
                         variable.name="Genome", value.name="Mean_Alignment_Score")

mean_scores_long$Genome <- factor(mean_scores_long$Genome, 
                                  levels=c("Mean_Score_hg38", "Mean_Score_hg19"),
                                  labels=c("Direct hg38", "Lifted hg19"))

ggplot(mean_scores_long, aes(x=Chrom_hg38, y=Mean_Alignment_Score, fill=Genome)) +
  geom_bar(stat="identity", position="dodge") +
  labs(title="Mean Alignment Score: Direct hg38 vs Lifted hg19",
       x="Autosomal Chromosome", 
       y="Mean Alignment Score") +
  scale_fill_manual(values=c("skyblue", "salmon")) +  # Different colors for comparison
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))  # Rotate x-axis labels
```

![](/A2graphs/meanGenomesAlignmentScore.png)<!-- --> \#?# 13.
Interpret the plot you created in Q12 above. What do you notice, explain
why you think the plot looks the way it does. (3 pts)

    Overall, most chromosomes show relatively minor differences between the two genomes, with both scores being consistently low, suggesting similar mappability across these chromosomes. However, chromosome 3 stands out dramatically with a much higher mean alignment score for both hg38 and hg19. This could suggest that there might be a region within this chromosome that is a lot easier to align, possibly due to highly conserved sequences or less complex repetitive elements.

    The consistency between the two genomes for most chromosomes indicates that the process of lifting over from hg19 to hg38 did not significantly alter the mappability across these chromosomes. This suggests that the genomic regions that are alignable in hg19 are generally still alignable in hg38.

    The anomaly on chromosome 3 could be due to several factors. It might indicate a region with high sequence conservation or low complexity, where alignment tools can easily find matches. Alternatively, it might point to a region in hg38 that was assembled with higher quality or has fewer gaps compared to hg19. Further investigation into this chromosome might reveal specific genomic features, such as gene clusters or conserved non-coding elements, contributing to this higher alignment score.

    https://gatk.broadinstitute.org/hc/en-us/articles/360035890951-Human-genome-reference-builds-GRCh38-or-hg38-b37-hg19

``` r
#?# 14. Create a boxplot illustrating the *difference* in start position of reads between the hg19 (lifted-over) and hg38 alignments for each of the autosomal chromosomes (2 pts)
library(ggplot2)
library(dplyr)

merged_data_autosomal <- merged_data %>%
  filter(Chrom_hg38 %in% paste0("chr", 1:22)) %>%
  mutate(Start_Diff = Start_hg38 - Start_hg19)

# Boxplot of start position differences per chromosome
ggplot(merged_data_autosomal, aes(x = Chrom_hg38, y = Start_Diff)) +
  geom_boxplot(outlier.colour = "red", outlier.size = 1) +
  theme_minimal() +
  labs(
    title = "Difference in Start Positions (Lifted hg19 vs. Direct hg38)",
    x = "Autosomal Chromosome",
    y = "Start Position Difference (bp)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

![](/A2graphs/differenceInStartPositionsBoxplot.png)<!-- -->

\#?# 15. Which chromosomes have the smallest difference(s) in start
position between the hg19 and hg38 alignments? Why do you think this is?
(2.5 pts)

    13, 14, 15, 22. These chromosomes have relatively small interquartile ranges (IQRs) and fewer extreme outliers compared to other chromosomes. Even though some chromosomes have very small IQRs they seem to have reasonably more outliers than most chromosomes still, such as chromosome 3. 

    They are acrocentric chromosomes. Chromosomes 13, 14, 15, and 22 (along with chromosome 21) belong to a group called acrocentric chromosomes, meaning they have their centromeres located very close to one end. Acrocentric chromosomes tend to have fewer large-scale structural changes between genome builds. Since their short arms are mostly repetitive and often excluded from mapping, the alignment differences between hg19 and hg38 are minimized. This suggests that genome assembly updates had less of an impact on these chromosomes compared to others, where structural changes, insertions, and improvements in assembly would be more prominent.

    https://en.wikipedia.org/wiki/Centromere

#### c. Effect of alignment mode on mappability

``` r
#?# 16. Plot another barchart comparing the number of uniquely mapped reads for each alignment mode (1 pt)

library(ggplot2)

single_file <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP150_hg38_single_nReads.txt"
paired_file <- "~/Downloads/H3K27me3_iPSC_SRA60_subset_CROP50_hg38_paired_nReads.txt"

single_reads <- as.numeric(readLines(single_file))
paired_reads <- as.numeric(readLines(paired_file))

data <- data.frame(
  Mode = c("Single", "Paired"),
  Reads = c(single_reads, paired_reads),
  Color = c("#AEC6CF", "#FFB347")  # Pastel blue and pastel orange
)

y_min <- min(data$Reads) - 50000
y_max <- max(data$Reads) + 50000
y_breaks <- seq(y_min, y_max, by = 50000)

# Create bar plot
ggplot(data, aes(x = Mode, y = Reads, fill = Color)) +
  geom_bar(stat = "identity") + 
  geom_text(aes(label = Reads), vjust = -0.5, size = 3) +  # Add labels on bars
  scale_fill_identity() +  # Use custom pastel colors
  theme_minimal() +
  labs(
    title = "Number of Uniquely Mapped Reads for Each Alignment Mode",
    x = "Alignment Mode",
    y = "Number of Uniquely Mapped Reads"
  ) +
  theme(
    axis.text.x = element_text(size = 12)
  )
```

![](/A2graphs/perAlignmentMode.png)<!-- -->

\#?# 17. As we saw before, the read length was directly related to the
number of uniquely mapped reads in a single-end alignment. Do you expect
a *similar* relationship (i.e. direction and rough size of slope) exists
for paired-end alignments? Why or why not? (1 pt)

    Yes, as shown in the graph above, there does appear to be a similar direction for the relationship as with single-end alignment; However, the size of the slope may be different due to key differences in how paired-end reads improve mappability. The total number of uniquely mapped reads is significantly higher in paired-end mode compared to single-end (as shown in the plot). This suggests that paired-end reads inherently reduce mapping uncertainty. Since paired-end reads already improve mapping accuracy, increasing read length may have a slightly smaller impact compared to single-end reads. However, the general trend should still be positive—longer reads will further improve mappability.

## Discussion (8 pts):

\#?# 18. Assuming a background genome **composed randomly** (made of
randomly sampled bases, 0.25 probability for each base), derive a
relationship between the length of a read and the probability that it
will map to a unique location in the random-genome. Show your work. (1
pts)

    (1/4)^k is probability of observing a k-length read in a random genome

    (1/4)^k * G is expected number of occurences in a genome of size G

    probability read is unique

    = e ^-λ * λ^1
    where λ = (1/4)^k * G (the expected occurences of the read)
    The probability of a read being unique, can be approximated using a poisson distribution.

    G * (1/4)^-k * e^-λ

\#?# 19. Would all 20bp sequences be expected to map to a random genome
(from Q18) with equal frequency? Why or why not? (1 pt)

    Not all 20bp sequences would map to a random genome with equal frequency. While a truly random genome assigns each base an equal probability (0.25), certain sequences—such as low-complexity regions, simple repeats (e.g., ATATAT…), and palindromic sequences (with identical reverse complements)—are naturally overrepresented. Additionally, overlapping k-mers increase the likelihood of encountering some sequences more frequently than others. These factors create unequal mapping probabilities, meaning some sequences are more likely to appear multiple times, leading to ambiguous mapping, while others remain unique.

\#?# 20. Would the difference between SE and PE alignment remain the
same if you had used the 150bp reads? Why or why not? (2 pts)

    No, the difference between single-end (SE) and paired-end (PE) alignment would not remain the same if we had used 150bp reads instead of shorter reads. The gap between uniquely mapped reads in SE and PE would likely decrease. This is because longer reads are more uniquely mappable, as we saw in the graph showing uniquely mapped reads against read length. As a result, the drastic difference between the number of uniquely mapped reads between the single and paired-alignment is likely far less. As in question 17, it became evident that the difference using paired-alignment makes is drastically more useful, but at a lower base pair length. PE reads help with mapping by providing an expected insert size and helping resolve repetitive regions, so the benefit should be reduced for longer read lengths.

\#?# 21. Trimmomatic can also be used to trim reads based on their
quality score. What impact will trimming reads according to read quality
to have on alignment/mapping? Use evidence from your data to test your
hypothesis. (4 pts)

    Trimming reads based on quality would likely improve mappability by removing sequencing errors that can cause mismatches, similar to how longer reads (Q7) resulted in more uniquely mapped reads. The improvement seen in paired-end sequencing (Q16) suggests that having more reliable sequence information helps with alignment, which is also a benefit of quality-based trimming. Since the difference in mappability between hg19 and hg38 was small (Q10), it indicates that the quality of the reads plays a bigger role in alignment success than the choice of reference genome. However, if too many low-quality bases are removed, reads may become too short to align properly, potentially reducing the total number of mapped reads. Based on this evidence, quality-based trimming would likely increase uniquely mapped reads while maintaining a balance between read length and alignment accuracy.

Chatlink:
<https://chatgpt.com/share/6799c4ed-0db0-800d-a378-b95bdf4c5413>

# Contributions

Mekail(35922863): Completed assignment collaboratively entirely.
Caden(56684616): Completed assignment collaboratively entirely.

Please note here the team members and their contributions to this
assignment.
